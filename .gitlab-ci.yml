# Define stages
stages:
  - test
  - notify
  - publish

# Define global workflow rules
# workflow:
#   rules:
#     # Run pipeline for MRs targeting the test workflow branch
#     - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "unit-test-workflow"'
#     # Run pipeline for tags on the test main branch
#     - if: '$CI_COMMIT_TAG && $CI_COMMIT_BRANCH == "${TEST_MAIN_BRANCH}"'

# Define variables
variables:
  NODE_VERSION: "20"
  YARN_VERSION: "1.22.22"
  YARN_CACHE_FOLDER: "$CI_PROJECT_DIR/.yarn-cache"
  NPM_CONFIG_CACHE: "$CI_PROJECT_DIR/.npm"
  SMTP_HOST: "smtp.office365.com"
  SMTP_PORT: "587"
  SMTP_SECURE: "false"
  # For testing, use local registry
  NPM_REGISTRY: "http://localhost:4873"
  NPM_AUTH_TOKEN: "MThkOWY3MTkwMzJiZGQ3NGUyNDY5ZjIwYWUyNzdjMzQ6ZGVlNjRkOGUyMWJiODdhZGIxOTVkZGYwZGFlMGQ1ZWNlYjZm"
  # Dummy branches for testing
  TEST_MAIN_BRANCH: "test-main"
  TEST_WORKFLOW_BRANCH: "unit-test-workflow"

# Cache configuration
cache:
  # The cache key is generated based on the yarn.lock file
  # When yarn.lock changes, a new cache is created
  key:
    files:
      - yarn.lock
  # Cache the node_modules directory to speed up builds
  # This prevents downloading dependencies on every pipeline run
  paths:
    - .yarn-cache/
    - node_modules/
  # pull-push policy:
  # - 'pull': tries to download cache before job execution
  # - 'push': uploads new cache after job completion
  # This ensures cache is both retrieved and updated
  policy: pull-push

# Default image
default:
  image: node:${NODE_VERSION}
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure

# Unit tests job
unit_tests:
  stage: test
  tags:
    - rmsdktest
  before_script:
    - |
      echo "=== Environment Variables Debug ==="
      echo "API_BASE_URL: ${API_BASE_URL}"
      echo "API_VERSION: ${API_VERSION}"
      echo "TEST_USERNAME: ${TEST_USERNAME}"
      echo "TEST_PASSWORD: ${TEST_PASSWORD}"
      echo "=== End Environment Variables Debug ==="
    - |
      if ! command -v yarn &> /dev/null; then
        npm install -g yarn@${YARN_VERSION}
      else
        echo "Yarn is already installed"
      fi
    - yarn --version
    # Set a higher network timeout (5 minutes) to prevent timeouts during package installation
    # This is especially important in CI environments where network conditions may be less reliable
    - yarn config set network-timeout 300000
    # Configure Yarn
    - yarn config set cache-folder ${YARN_CACHE_FOLDER}
    # Install dependencies with frozen-lockfile to prevent unexpected changes
    - yarn install --frozen-lockfile --prefer-offline
    # Create .env.test file for tests using GitLab CI/CD variables
    - |
      cat > .env.test << EOF
      API_BASE_URL=${API_BASE_URL}
      API_VERSION=${API_VERSION}
      USERNAME=${TEST_USERNAME}
      PASSWORD=${TEST_PASSWORD}
      EOF
    # Debug: Print the contents of .env.test (excluding sensitive data)
    - echo "=== .env.test Contents ==="
    - cat .env.test | sed 's/PASSWORD=.*/PASSWORD=[MASKED]/'
    - echo "=== End .env.test Contents ==="
  script:
    - echo "Running unit tests..."
    - yarn test
  coverage: '/All files[^|]*\\|[^|]*\\s+([\\d\\.]+)/'
  artifacts:
    when: always
    reports:
      junit: junit.xml
    paths:
      - coverage/
      - .env.test
      - junit.xml
    expire_in: 1 week
  rules:
    # This job should run automatically ONLY within MR pipelines targeting the test workflow branch
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "unit-test-workflow"'
      when: on_success # Explicitly run on success within the pipeline
    # No other rules needed, workflow:rules controls pipeline creation
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
      - script_failure
  after_script:
    # Temporarily commented out for debugging
    # - rm -f .env.test

# Notification job
notify_test_results:
  stage: notify
  tags:
    - rmsdktest
  needs:
    - unit_tests
  before_script:
    - yarn add nodemailer handlebars
  script:
    - |
      node -e "
      const nodemailer = require('nodemailer');
      const fs = require('fs');
      const Handlebars = require('handlebars');

      // Debug logs
      console.log('=== Email Configuration Debug ===');
      console.log('SMTP Host:', '$SMTP_HOST');
      console.log('SMTP Port:', '$SMTP_PORT');
      console.log('SMTP Secure:', $SMTP_SECURE === 'true');
      console.log('Email User:', '$EMAIL_USER');
      console.log('To Emails:', '$TO_EMAILS');
      console.log('=== End Configuration Debug ===');

      const transporter = nodemailer.createTransport({
        host: '$SMTP_HOST',
        port: '$SMTP_PORT',
        secure: $SMTP_SECURE === 'true',
        auth: {
          user: '$EMAIL_USER',
          pass: '$EMAIL_PASSWORD'
        }
      });

      // Test SMTP connection
      console.log('Testing SMTP connection...');
      transporter.verify(function(error, success) {
        if (error) {
          console.error('SMTP Connection Error:', error);
          process.exit(1);
        } else {
          console.log('SMTP Connection Successful!');
        }
      });

      // Read and compile the Handlebars template
      const template = fs.readFileSync('ci/email-template.html', 'utf8');
      const compiledTemplate = Handlebars.compile(template);

      // Prepare the data for the template
      const data = {
        pipelineUrl: '$CI_PIPELINE_URL',
        testReportUrl: '$CI_PIPELINE_URL/test_report?job_name=unit_tests',
        branchName: '$CI_COMMIT_REF_NAME',
        projectUrl: '$CI_PROJECT_URL',
        projectName: '$CI_PROJECT_NAME',
      };

      // Render the template with the data
      const html = compiledTemplate(data);

      const mailOptions = {
        from: '$EMAIL_USER',
        to: '$TO_EMAILS',
        subject: '[' + data.projectName + '] Test Report - ' + new Date().toISOString().split('T')[0],
        html: html
      };

      transporter.sendMail(mailOptions, (error, info) => {
        if (error) {
          console.error('Error sending email:', error);
          process.exit(1);
        } else {
          console.log('Email sent:', info.response);
          process.exit(0);
        }
      });"
  rules:
    # Rule for MRs targeting the test workflow branch
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "unit-test-workflow"'
      when: on_success
    - when: manual # Keep manual option for this job
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
  allow_failure: true # Allow this job to fail without failing the pipeline for MWPS

# Publish package job
publish-package:
  stage: publish
  tags:
    - rmsdktest
  before_script:
    - |
      if ! command -v yarn &> /dev/null; then
        npm install -g yarn@${YARN_VERSION}
      else
        echo "Yarn is already installed"
      fi
    - yarn --version
    - yarn config set network-timeout 300000
    - yarn config set cache-folder ${YARN_CACHE_FOLDER}
    # For testing, use local registry
    - echo "registry=${NPM_REGISTRY}" > .npmrc
    # Login to Verdaccio
    - echo "//localhost:4873/:_authToken=${NPM_AUTH_TOKEN}" >> .npmrc
    # For testing, use a test package name
    - node -e "const pkg = require('./package.json'); pkg.name = '@test/rainmaker-base-sdk-test'; require('fs').writeFileSync('./package.json', JSON.stringify(pkg, null, 2));"
  script:
    - yarn install --frozen-lockfile --prefer-offline
    - yarn run build
    - yarn publish --new-version ${CI_COMMIT_TAG#v}
  rules:
    # Rule for tags on the test main branch
    - if: $CI_COMMIT_TAG && $CI_COMMIT_BRANCH == "${TEST_MAIN_BRANCH}" && $CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/
      when: on_success
    - when: never # Prevent running in other cases
  retry:
    max: 2
  allow_failure: false
